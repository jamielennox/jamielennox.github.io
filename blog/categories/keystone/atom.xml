<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Keystone | jamielennox.net]]></title>
  <link href="http://www.jamielennox.net/blog/categories/keystone/atom.xml" rel="self"/>
  <link href="http://www.jamielennox.net/"/>
  <updated>2014-12-01T16:00:36+10:00</updated>
  <id>http://www.jamielennox.net/</id>
  <author>
    <name><![CDATA[Jamie Lennox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PKI Tokens Don't Give Better Security]]></title>
    <link href="http://www.jamielennox.net/blog/2014/12/01/pki-tokens-dont-give-better-security/"/>
    <updated>2014-12-01T12:55:29+10:00</updated>
    <id>http://www.jamielennox.net/blog/2014/12/01/pki-tokens-dont-give-better-security</id>
    <content type="html"><![CDATA[<p>This will be real quick.</p>

<p>Every now and then I come across something that mentions how you should use PKI tokens in keystone as the cryptography gives it better security.
It happened today and so I thought I should clarify:</p>

<p><strong>There is no added security benefit to using keystone with PKI tokens over UUID tokens.</strong></p>

<p>There are advantages to PKI tokens:</p>

<ul>
<li>Token validation without a request to keystone means less impact on keystone.</li>
</ul>


<p>And there are disadvantages:</p>

<ul>
<li>Larger token size.</li>
<li>Additional complexity to set up.</li>
</ul>


<p>However the fundamental model, that this opaque chunk of data in the &lsquo;X-Auth-Token&rsquo; header indicates that this request is authenticated does not change between PKI and UUID tokens.
If someone steals your PKI token you are just as screwed as if they stole your UUID token.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Use Keystoneclient Sessions]]></title>
    <link href="http://www.jamielennox.net/blog/2014/09/15/how-to-use-keystoneclient-sessions/"/>
    <updated>2014-09-15T09:13:36+10:00</updated>
    <id>http://www.jamielennox.net/blog/2014/09/15/how-to-use-keystoneclient-sessions</id>
    <content type="html"><![CDATA[<p>In the last post I did on keystoneclient sessions there was a lot of hand waving about how they should work but it&rsquo;s not merged yet.
Standardizing clients has received some more attention again recently - and now that the sessions are more mature and ready it seems like a good opportunity to explain them and how to use them again.</p>

<p>For those of you new to this area the clients have grown very organically, generally forking off some existing client and adding and removing features in ways that worked for that project.
Whilst this is in general a problem for user experience (try to get one token and use it with multiple clients without reauthenticating) it is a nightmare for security fixes and new features as they need to be applied individually across each client.</p>

<p>Sessions are an attempt to extract a common authentication and communication layer from the existing clients so that we can handle transport security once, and keystone and deployments can add new authentication mechanisms without having to do it for every client.</p>

<h2>The Basics</h2>

<p>Sessions and authentications are user facing objects that you create and pass to a client, they are public objects not a framework for the existing clients.
They require a change in how you instantiate clients.</p>

<p>The first step is to create an authentication plugin, currently the available plugins are:</p>

<ul>
<li><code>keystoneclient.auth.identity.v2.Password</code></li>
<li><code>keystoneclient.auth.identity.v2.Token</code></li>
<li><code>keystoneclient.auth.identity.v3.Password</code></li>
<li><code>keystoneclient.auth.identity.v3.Token</code></li>
<li><code>keystoneclient.auth.token_endpoint.Token</code></li>
</ul>


<p>For the primary user/password and token authentication mechanisms that keystone supports in v2 and v3 and for the test case where you know the endpoint and token in advance.
The parameters will vary depending upon what is required to authenticate with each.</p>

<p>Plugins don&rsquo;t need to live in the keystoneclient, we are currently in the process of setting up a new repository for kerberos authentication so that it will be an optional dependency.
There are also some plugins living in the contrib section of keystoneclient for federation that will also likely be moved to a new repository soon.</p>

<p>You can then create a session with that plugin.</p>

<pre><code class="python">
from keystoneclient import session as ksc_session
from keystoneclient.auth.identity import v3
from keystoneclient.v3 import client as keystone_v3
from novaclient.v1_1 import client as nova_v2

auth = v3.Password(auth_url='http://keystone.host/v3',
                   username='user',
                   password='password',
                   project_name='demo',
                   user_domain_name='default',
                   project_domain_name='default')

session = ksc_session.Session(auth=auth,
                              verify='/path/to/ca.cert')

keystone = keystone_v3.Client(session=session)
nova = nova_v2.Client(session=session)
</code></pre>

<p>Keystone and nova clients will now share an authentication token fetched with keystone&rsquo;s v3 authentication.
The clients will authenticate on the first request and will re-authenticate automatically when the token expires.</p>

<p>This is a fundamental shift from the existing clients that would authenticate internally to the client and on creation so by opting to use sessions you are acknowledging that some methods won&rsquo;t work like they used to.
For example keystoneclient had an <code>authenticate()</code> function that would save the details of the authentication (user_id etc) on the client object.
This process is no longer controlled by keystoneclient and so this function should not be used, however it also cannot be removed because we need to remain backwards compatible with existing client code.</p>

<p>In converting the existing clients we consider that passing a Session means that you are acknowledging that you are using new code and are opting-in to the new behaviour.
This will not affect 90% of users who just make calls to the APIs, however if you have got hacks in place to share tokens between the existing clients or you overwrite variables on the clients to force different behaviours then these will probably be broken.</p>

<h2>Per-Client Authentication</h2>

<p>The above flow is useful for users where they want to have there one token shared between one or more clients.
If you are are an application that uses many authentication plugins (eg, heat or horizon) you may want to take advantage of using a single session&rsquo;s connection pooling or caching whilst juggling multiple authentications.
You can therefore create a session without an authentication plugin and specify the plugin that will be used with that client instance, for example:</p>

<pre><code class="python">global SESSION

if not SESSION:
    SESSION = ksc_session.Session()

auth = get_auth_plugin()  # you could deserialize it from a db,
                          # fetch it based on a cookie value...
keystone = keystone_v3.Client(session=SESSION, auth=auth)
</code></pre>

<p>Auth plugins set on the client will override any auth plugin set on the session - but I&rsquo;d recommend you pick one method based on your application&rsquo;s needs and stick with it.</p>

<h2>Loading from a config file</h2>

<p>There is support for loading session and authentication plugins from and oslo.config CONF object.
The documentation on exactly what options are supported is lacking right now and you will probably need to look at code to figure out everything that is supported.
I promise to improve this, but to get you started you need to register the options globally:</p>

<pre><code class="python">group = 'keystoneclient'  # the option group
keystoneclient.session.Session.register_conf_options(CONF, group)
keystoneclient.auth.register_conf_options(CONF, group)
</code></pre>

<p>And then load the objects where you need them:</p>

<pre><code class="python">auth = keystoneclient.auth.load_from_conf_options(CONF, group)
session = ksc_session.Session.load_from_conf_options(CONF, group, auth=auth)
keystone = keystone_v3.Client(session=session)
</code></pre>

<p>Will load options that look like:</p>

<pre><code class="ini">[keystoneclient]
cacert = /path/to/ca.cert
auth_plugin = v3password
username = user
password = password
project_name = demo
project_domain_name = default
user_domain_name = default
</code></pre>

<p>There is also support for transitioning existing code bases to new option names if they are not the same as what your application uses.</p>

<h2>Loading from CLI</h2>

<p>A very similar process is used to load sessions and plugins from an argparse parser.</p>

<pre><code class="python">
parser = argparse.ArgumentParser('test')

argv = sys.argv[1:]

keystoneclient.session.Session.register_cli_options(parser)
keystoneclient.auth.register_argparse_arguments(parser, argv)

args = parser.parse_args(argv)

auth = keystoneclient.auth.load_from_argparse_arguments(args)
session = keystoneclient.session.Session.load_from_cli_options(args,
                                                               auth=auth)
</code></pre>

<p>This produces an application with the following options:</p>

<pre><code class="bash">python test.py --os-auth-plugin v3password
usage: test [-h] [--insecure] [--os-cacert &lt;ca-certificate&gt;]
            [--os-cert &lt;certificate&gt;] [--os-key &lt;key&gt;] [--timeout &lt;seconds&gt;]
            [--os-auth-plugin &lt;name&gt;] [--os-auth-url OS_AUTH_URL]
            [--os-domain-id OS_DOMAIN_ID] [--os-domain-name OS_DOMAIN_NAME]
            [--os-project-id OS_PROJECT_ID]
            [--os-project-name OS_PROJECT_NAME]
            [--os-project-domain-id OS_PROJECT_DOMAIN_ID]
            [--os-project-domain-name OS_PROJECT_DOMAIN_NAME]
            [--os-trust-id OS_TRUST_ID] [--os-user-id OS_USER_ID]
            [--os-user-name OS_USERNAME]
            [--os-user-domain-id OS_USER_DOMAIN_ID]
            [--os-user-domain-name OS_USER_DOMAIN_NAME]
            [--os-password OS_PASSWORD]
</code></pre>

<p>There is an ongoing effort to create a standardized CLI plugin that can be used by new clients rather than have people provide an &ndash;os-auth-plugin every time.
It is not yet ready, however clients can create and specify there own default plugins if &ndash;os-auth-plugin is not provided.</p>

<h2>For Client Authors</h2>

<p>To make use of the session in your client there is the <code>keystoneclient.adapter.Adapter</code> which provides you with a set of standard variables that your client should take and use with the session.
The adapter will handle the per-client authentication plugins, handle <code>region_name</code>, <code>interface</code>, <code>user_agent</code> and similar client parameters that are not part of the more global (across many clients) state that sessions hold.</p>

<p>The basic client should look like:</p>

<pre><code>class MyClient(object):

    def __init__(self, **kwargs):
        kwargs.set_default('user_agent', 'python-myclient')
        kwargs.set_default('service_type', 'my')
        self.http = keystoneclient.adapter.Adapter(**kwargs)
</code></pre>

<p>The adapter then has <code>.get()</code> and <code>.post()</code> and other http methods that the clients expect.</p>

<h2>Conclusion</h2>

<p>It&rsquo;s great to have renewed interest in standardizing client behaviour, and I&rsquo;m thrilled to see better session adoption.
The code has matured to the point it is usable and simplifies use for both users and client authors.</p>

<p>In writing this I kept wanting to link out to official documentation and realized just how lacking it really is.
Some explanation is available on the <a href="http://docs.openstack.org/developer/python-keystoneclient/using-sessions.html">official python-keystoneclient docs pages</a>, there is also <a href="http://docs.openstack.org/developer/python-keystoneclient/api/keystoneclient.auth.identity.html">module documentation</a> however this is definetly an area in which we (read I) am a long way behind.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Identity_uri in Auth Token Middleware]]></title>
    <link href="http://www.jamielennox.net/blog/2014/05/21/identity-uri-in-auth-token-middleware/"/>
    <updated>2014-05-21T14:54:00+10:00</updated>
    <id>http://www.jamielennox.net/blog/2014/05/21/identity-uri-in-auth-token-middleware</id>
    <content type="html"><![CDATA[<p>As part of the 0.8 release of keystoneclient (2014-04-17) we made an update to the way that you configure auth_token middleware in OpenStack.</p>

<p>Previously you specify the path to the keystone server as a number of individual parameters such as:</p>

<pre><code>[keystone_authtoken]
auth_protocol = http
auth_port = 35357
auth_host = 127.0.0.1
auth_admin_prefix =
</code></pre>

<p>This made sense in code when using httplib for communication where you use each of those independent pieces.
However we removed httplib a number of releases ago and now simply reconstruct the full URL in code in the form:</p>

<pre><code>%(auth_protocol)s://%(auth_host)s:%(auth_port)d/%(auth_admin_prefix)s
</code></pre>

<p>This format is much more intuitive for configuration and so should now be used with the key <strong>identity_uri</strong>. e.g.</p>

<pre><code>[keystone_authtoken]
identity_uri = http://127.0.0.1:35357
</code></pre>

<p>Using the original format will continue to work but you&rsquo;ll see a deprecation message like:</p>

<pre><code>WARNING keystoneclient.middleware.auth_token [-] Configuring admin URI using auth fragments. This is deprecated, use 'identity_uri' instead.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keystone Token Binding]]></title>
    <link href="http://www.jamielennox.net/blog/2013/10/22/keystone-token-binding/"/>
    <updated>2013-10-22T11:48:00+10:00</updated>
    <id>http://www.jamielennox.net/blog/2013/10/22/keystone-token-binding</id>
    <content type="html"><![CDATA[<p>With the Havana release of OpenStack, Keystone gains the ability to issue and verify tokens &ldquo;bound&rdquo; to some authentication mechanism.
To understand the reason for this feature we need to first consider the security model of the current token architecture.</p>

<p>OpenStack tokens are what we call &ldquo;bearer tokens&rdquo;.
The term seems to have come out of the OAuth movement but means that whoever has the token has all the rights associated with that person.
This is not an uncommon situation on the Internet, it is the way basic auth (username and password), cookies, and session ids all work, and one of the reasons that SSL is so important when authenticating against a website.
If an attacker was to get your token then they have all the rights of that token for as long as it is valid, including permission to reissue a token or change your password.
While all of these mechanism are symmetric secrets, they are only shared between two end points.
Keystone tokens are shared across all of the public services in an OpensStack deployment.</p>

<p>As OpenStack grows and this token is presented to an ever increasing list of services the vulnerability of this mechanism increases.
So what can we do about it?
The typical answer, particularly for the enterprise, is to use Kerberos or x509 client certificates.
This is a great solution but we don&rsquo;t want to have each service dealing with different authentication mechanisms, that&rsquo;s what Keystone does.</p>

<h2>What is a &ldquo;bound token&rdquo;?</h2>

<p>A &ldquo;bound token&rdquo; is a regular keystone token with some additional information that indicates that the token may only be used in conjunction with the specified external authentication mechanism.
Taking the example of Kerberos, when a token is issued Keystone embeds the name of the Kerberos principle into the token.
When this token is then presented to another service the service notices the bind information and ensures that Kerberos authentication was used and that the same user is making the request.</p>

<p>So how does this help to protect token hijacking?
To give an example:</p>

<ol>
<li> Alice connects to Keystone using her Kerberos credentials and gets a token.
 Embedded within this token is her Kerberos principal name <code>alice@ACME.COM</code>.</li>
<li> Alice authenticates to HaaS (hacked as a service) using her token and Kerberos credentials and is allowed to perform her operations.</li>
<li> Bob, who has privileged access to HaaS, records the token that Alice presented to the service (or otherwise gets Alice&rsquo;s token)</li>
<li> Bob attempts to connect to Keystone as Alice to change her password.
 He connects to keystone with his own Kerberos credentials <code>bob@ACME.COM</code>.
 Because these credentials do not match the ones that were present when the token was created his access is disallowed.</li>
</ol>


<p>It does not necessarily mean that the user initially authenticated themselves by there Kerberos credentials, they may have used there regular username and password.
It simply means that the user who created the token has said that they are also the owner of this Kerberos principal (note: that it is tied to the principal, not a ticket so it will survive ticket re-issuing) and the token should not be authenticated in future without it present.</p>

<h2>What is implemented?</h2>

<p>Currently tokens issued from Keystone can be bound to a Kerberos principal.
Extending this mechanism to x509 client certificates should be a fairly simple exercise but will not be included in the Havana release.</p>

<p>A patch to handle bind checking in auth_token middleware is currently under review to bring checking to other services.</p>

<p>There are however a number of problems with enforcing bound tokens today:</p>

<ul>
<li>Kerberos authentication is not supported by the eventlet http server (the server that drives most of the OpenStack web services), and so there is no way to authenticate to the server to provide the credentials.
This essentially restricts bind checking to services running in httpd, which to the best of my knowledge is currently only keystone and swift.</li>
<li>None of the clients currently support connecting with Kerberos authentication.
The option was added to Keystoneclient as a proof of concept but I am hoping that this can be solved across all clients by standardizing the way they communicate rather than having to add and maintain support in each individual client.
There will also be the issue of how to configure the servers to use these clients correctly.</li>
<li>Kerberos tickets are issued to users, not hosts, and typically expire after a period of time.
To allow unattended servers to have valid Kerberos credentials requires a way of automatically refreshing or fetching new tickets.
I am told that there is support for this scenario coming in Fedora 20 but I am not sure what it will involve.</li>
</ul>


<h2>Configuring Token Binding</h2>

<p>The new argument to enable token binding in <code>keystone.conf</code> is:</p>

<pre><code>[token]

# External auth mechanisms that should add bind information to token.
# eg kerberos, x509
bind = kerberos
</code></pre>

<p>As mentioned currently only the value Kerberos is currently supported here.
One of the next supported mechanisms will be x509 client certificates.</p>

<p>To enable token bind authentication in <code>keystone.conf</code> is:</p>

<pre><code>[token]
# Enforcement policy on tokens presented to keystone with bind information.
# One of disabled, permissive, strict, required or a specifically required bind
# mode e.g. kerberos or x509 to require binding to that authentication.
enforce_token_bind = permissive
</code></pre>

<p>As illustrated by the comments the possible values here are:</p>

<ul>
<li><code>disabled</code>: Disables token bind checking.</li>
<li><code>permissive</code>: Token bind information will be verified if present.
 If there is bind information for a token and the server does not know how to verify that information then it will be ignored and the token will be allowed.
 This is the new default value and should have no effect on existing systems.</li>
<li><code>strict</code>: Like permissive but if unknown bind information is present then the token will be rejected.</li>
<li><code>required</code>: Tokens will only be allowed if bind information is present and verified.</li>
<li>A specific form of bind information is present and verified.
The only currently available value here is <code>kerberos</code> indicating that a token must be bound to a Kerberos principal to be accepted.</li>
</ul>


<h2>In Conclusion</h2>

<p>For a deployment with access to a Kerberos or x509 infrastructure token binding will dramatically increase your user&rsquo;s security.
Unfortunately the limitations of Kerberos within OpenStack don&rsquo;t really make this a viable deployment option in Havana.
Watch this space however as we add x509 authentication and binding, and improve Kerberos handling throughout.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keystone With HTTPd in Devstack]]></title>
    <link href="http://www.jamielennox.net/blog/2013/09/30/keystone-with-httpd-in-devstack/"/>
    <updated>2013-09-30T13:53:00+10:00</updated>
    <id>http://www.jamielennox.net/blog/2013/09/30/keystone-with-httpd-in-devstack</id>
    <content type="html"><![CDATA[<p>Keystone has been slowly pushing away from being deployed with <a href="http://eventlet.net">Eventlet</a> and the <code>keystone-all</code> script in favour of the more traditional httpd mod_wsgi application method.
There has been discussion of Eventlet&rsquo;s place in OpenStack <a href="http://davidhadas.wordpress.com/2012/05/14/asynchronousio/">before</a> and its (mis)use has led to numerous subtle bugs and problems, however from my opinion in Keystone the most important reasons to move away from Eventlet are:</p>

<ul>
<li>Eventlet does not support Kerberos authentication.</li>
<li>pyOpenSSL only releases the GIL around some SSL verification commands.
This leads to a series of hacks to prevent long running crypto commands blocking Eventlet threads and thus the entire Keystone process.</li>
<li>There are already a lot of httpd authentication/authorization plugins that we could make use of in Keystone.</li>
<li>It&rsquo;s faster to have things handled by httpd modules in C than in Python.</li>
</ul>


<p>Keystone has shipped with sample WSGI scripts and httpd configuration files since Foslom and documentation for how to use them <a href="http://docs.openstack.org/developer/keystone/apache-httpd.html">is available</a> however most guides and service wrappers (upstart, systemd etc) will use the <code>keystone-all</code> method.</p>

<p>To get some wider adoption and understanding of the process I&rsquo;ve just added Keystone with httpd support into devstack.
Simply set:
<code>
APACHE_ENABLED_SERVICES=key
</code>
in your localrc or environment variables and re-run <code>./stack.sh</code> to try it out.</p>

<p>P.S. Swift can also be deployed this way by adding <code>swift</code> to the (comma separated) services list.</p>
]]></content>
  </entry>
  
</feed>
