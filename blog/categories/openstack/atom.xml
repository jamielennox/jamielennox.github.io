<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Openstack | jamielennox.net]]></title>
  <link href="http://www.jamielennox.net/blog/categories/openstack/atom.xml" rel="self"/>
  <link href="http://www.jamielennox.net/"/>
  <updated>2016-10-05T16:44:31+11:00</updated>
  <id>http://www.jamielennox.net/</id>
  <author>
    <name><![CDATA[Jamie Lennox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing With Auth_token Middleware]]></title>
    <link href="http://www.jamielennox.net/blog/2016/10/05/testing-with-auth-token-middleware/"/>
    <updated>2016-10-05T17:28:21+11:00</updated>
    <id>http://www.jamielennox.net/blog/2016/10/05/testing-with-auth-token-middleware</id>
    <content type="html"><![CDATA[<p>For most OpenStack services the auth_token middleware component is the only direct interaction the service will have with keystone.
It is the piece of the service that validates the token a user presents and relays the stored information.</p>

<p>When testing a service we want to ensure that the middleware is working and presenting the correct information but not actually talking to keystone.
To do this keystonemiddleware provides a fixture that will stub out the interaction with keystone with an existing token.</p>

<p>If all that makes sense to you then at this point I think you mostly just want a code example and you can research anything else you need.</p>

<pre><code class="python">import json

from keystoneauth1 import fixture as ksa_fixture
from keystonemiddleware import auth_token
from keystonemiddleware import fixture as ksm_fixture
from oslo_context import context
import testtools
import webob.dec
import webtest


@webob.dec.wsgify
def app(request):
    """A really simple WSGI application that returns some context info."""

    # don't try to figure out what AuthToken sets, just use a context
    ctxt = context.RequestContext.from_environ(request.environ, overwrite=False)

    # return some information from context so we can verify the test
    resp_body = {'project_id': ctxt.tenant,
                 'user_id': ctxt.user,
                 'auth_token': ctxt.auth_token}

    return webob.Response(json.dumps(resp_body),
                          status_code=200,
                          content_type='application/json')


class Tests(testtools.TestCase):

    @staticmethod
    def load_app():
        # load your wsgi app here, wrapped in auth_token middleware
        return auth_token.AuthProtocol(app, {})

    @staticmethod
    def create_token():
        """Create a fake token that will be used in testing"""

        # Creates a project scoped V3 token, with 1 entry in the catalog
        token = ksa_fixture.V3Token()
        token.set_project_scope()

        s = token.add_service('identity')
        s.add_standard_endpoints(public='http://example.com/identity/public',
                                 admin='http://example.com/identity/admin',
                                 internal='http://example.com/identity/internal',
                                 region='RegionOne')

        return token

    def setUp(self):
        super(Tests, self).setUp()

        # create our app. webtest gives us a callable interface to it
        self.app = webtest.TestApp(self.load_app())

        # stub out auth_token middleware
        self.auth_token_fixture = self.useFixture(ksm_fixture.AuthTokenFixture())

        # create a token, mock it and save it and the ID for later use
        self.token = self.create_token()
        self.token_id = self.auth_token_fixture.add_token(self.token)

    def test_auth_token_params(self):
        # make a request with the stubbed out token_id and unpack the response
        body = self.app.get('/', headers={'X-Auth-Token': self.token_id}).json

        # ensure that the information in our stubbed token made it to the app
        self.assertEqual(self.token_id, body['auth_token'])
        self.assertEqual(self.token.project_id, body['project_id'])
        self.assertEqual(self.token.user_id, body['user_id'])
</code></pre>

<p>The important pieces are:</p>

<ul>
<li><a href="http://docs.pylonsproject.org/projects/webtest/en/latest/">Webtest</a> is a useful testing library emulating a wsgi layer so you can make requests.</li>
<li><a href="http://docs.openstack.org/developer/keystoneauth/api/keystoneauth1.fixture.html#keystoneauth1.fixture.v3.Token">ksa_fixture.V3Token</a> is a helper that builds the correct raw data layout for a V3 token.</li>
<li><a href="http://docs.openstack.org/developer/keystonemiddleware/api/keystonemiddleware.html#keystonemiddleware.fixture.AuthTokenFixture">AuthTokenFixture</a> is doing the mocking and returning the token data.</li>
<li><a href="http://docs.openstack.org/developer/oslo.context/api/context.html#oslo_context.context.RequestContext.from_environ">RequestContext.from_environ</a> takes the information auth_token sets into headers and loads it into the standard place in a RequestContext.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Positional Library]]></title>
    <link href="http://www.jamielennox.net/blog/2016/07/13/the-positional-library/"/>
    <updated>2016-07-13T15:27:52+10:00</updated>
    <id>http://www.jamielennox.net/blog/2016/07/13/the-positional-library</id>
    <content type="html"><![CDATA[<p>So one of my favourite things in python 3 syntax is:</p>

<pre><code class="python">def function(arg, *, kw1, kw2=None):
</code></pre>

<p>This <code>*</code> syntax says that <code>kw1</code> and <code>kw2</code> must be presented as keyword
arguments. Being that <code>kw1</code> is after the <code>*</code> and does not have a default value
it becomes a required keyword argument.</p>

<pre><code class="python">function('a', kw1=1)
</code></pre>

<p>This may seem kind of pedantic but the traditional python syntax does not
distinguish between optional arguments and positional arguments with defaults.
This means if your function has a large number of keyword arguments you cannot
assume your users don&rsquo;t pass all those arguments positionally (I&rsquo;ve seen it).
This makes it difficult to refactor these functions because you cannot
reorganize or bundle those arguments up into <code>**kwargs</code> later.</p>

<p>In <a href="https://git.openstack.org/cgit/openstack/keystoneauth">keystoneauth</a> we
have a number of functions like this that have a lot of optional arguments but
for future proofing we want to ensure people only pass them via keyword. So we
created the <a href="https://pypi.python.org/pypi/positional">positional</a> library.</p>

<p>The <a href="https://github.com/morganfainberg/positional">README</a> has a number of
detailed examples of use, but in general it provides a python 2 and 3
compatible way to ensure your users pass parameters via keyword.</p>

<pre><code class="python">from positional import positional

@positional()
def function(arg, kw1=None, kw2=None):
    # do stuff

# must pass kw1 and kw2 as keyword arguments
function('a', kw1=1, kw2=2)
</code></pre>

<p>By default specifying only the positional decorator every argument with a
default value that is passed to the function must be passed via keyword.
Specifying a number in the decorator lets you control the number of arguments
that can be passed positionally to the function:</p>

<pre><code class="python">@positional(2)
def function(arg, kw1=None, kw2=None):
    # do stuff

# kw1 has a default but can also be passed positionally
function('a', 1, kw2=2)
</code></pre>

<p>Later replacing this function with:</p>

<pre><code class="python">
@positional()
def worker(kw2=None, kw3=None):
    # do stuff

@positional(2)
def function(arg, kw1=None, **kwargs):
    worker(**kwargs)

function('a', 1, kw2=2)
</code></pre>

<p>is completely backwards compatible because there is no way a user could have
provided <code>kw2</code> as a positional argument.</p>

<p>I look forward to the day when we are all in a python 3 only world and
<code>@positional</code> is no longer required. Until then it has already allowed us to do
a number of library refactors that would have otherwise been much more
difficult.</p>

<p>Thanks to <a href="https://twitter.com/MdrnStm">Morgan Fainberg</a> for the help and
upkeep on positional.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Os-http]]></title>
    <link href="http://www.jamielennox.net/blog/2016/04/12/os-http/"/>
    <updated>2016-04-12T12:57:25+10:00</updated>
    <id>http://www.jamielennox.net/blog/2016/04/12/os-http</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>Frequently doing OpenStack development I find myself wanting to query an API directly and observe the response.
This is a fairly common development task, but it&rsquo;s more complicated in OpenStack because there is an order in which you are supposed to make calls.
The ideal flow is:</p>

<ul>
<li>authenticate using credentials (username/password or a range of other mechanisms)</li>
<li>use the service catalog returned with authentication to find the endpoint for a service</li>
<li>find the API version URL you want from the service&rsquo;s endpoint</li>
<li>make a request to the versioned URL</li>
</ul>


<p>So we generally end up simply using a combination of curl and <a href="https://stedolan.github.io/jq/">jq</a> against a known endpoint with an existing token.
This pattern has existed for so long that the <code>--debug</code> output of most clients is actually in curl command form.
There are numerous drawbacks to this approach including:</p>

<ul>
<li>you have to manually refresh tokens when they expire.</li>
<li>you have to know the endpoints ahead of time.</li>
<li>for security reasons the actual token is no longer displayed so you can&rsquo;t simply copy the outputted curl command.</li>
<li>you have to remember all the curl/other tool commands for showing headers, readable output etc - YMMV on this but I always forget.</li>
</ul>


<h2>Introducing os-http</h2>

<p>os-http is an easy to use CLI tool for making requests against OpenStack endpoints correctly.
It&rsquo;s designed to allow developers to debug and inspect the responses of OpenStack REST APIs without having to manage the details of authentication, service catalog and version negotiation.
Its interface is 100% modelled on the excellent <a href="https://github.com/jkbrzt/httpie">httpie</a>.</p>

<p>I have recently added the 0.1 release to <a href="https://pypi.python.org/pypi/os-http/">pypi</a> and the source is available <a href="https://github.com/jamielennox/os-http">on my github</a> though it will probably migrate to the OpenStack infrastructure if it gains adoption.
It is released under the Apache 2 License.</p>

<p>It is still very raw and but I have been using it for some time and feel it may be useful for others.
It is also in fairly desperate need of documentation - contributions welcome.</p>

<h2>Example</h2>

<p>Because it&rsquo;s powered by <a href="https://pypi.python.org/pypi/os-client-config">os-client-config</a> the authentication configuration is what you would expect from using <a href="https://pypi.python.org/pypi/python-openstackclient">openstackclient</a>.
Documentation for preparing this authentication is available from both of these projects.</p>

<pre><code class="console">export OS_CLOUD=devstack
</code></pre>

<p>There are then a number of choices you can make for service discovery:</p>

<pre><code class="console">--os-service-type &lt;name&gt;    Service type to request from the catalog
--os-service-name &lt;name&gt;    Service name to request from the catalog
--os-interface &lt;name&gt;       API Interface to use [public, internal, admin]
--os-region-name &lt;name&gt;     Region of the cloud to use
--os-endpoint-override &lt;url&gt;  Endpoint to use instead of the endpoint in the catalog
--os-api-version &lt;version&gt;  Which version of the service API to use
</code></pre>

<p>As is standard for OpenStack clients these options are also able to be set via the corresponding OS_ environment varibles:</p>

<pre><code class="console">export OS_SERVICE_TYPE=image
export OS_API_VERSION=2
</code></pre>

<p>The syntax for commands is then <code>os-http METHOD PATH [ITEM [ITEM]]</code>.
 <code>ITEM</code> currently only accepts headers in a <code>key:value</code> format but will support others in future.</p>

<pre><code class="console">jamie@devstack:~$ os-http get /images X-My-Header:Value
HTTP/1.1 200 OK
Date: Tue, 12 Apr 2016 01:35:31 GMT
Connection: keep-alive
Content-Type: application/json; charset=UTF-8
Content-Length: 1987
X-Openstack-Request-Id: req-3f6e07e7-cd0d-4a90-9d8a-0024a4bc347f


{
    "first": "/v2/images",
    "images": [
        {
            "checksum": "eb9139e4942121f22bbc2afc0400b2a4",
            "container_format": "ami",
            "created_at": "2016-03-08T01:56:59Z",
            "disk_format": "ami",
            "file": "/v2/images/6c13a0e6-98a3-47fb-bee4-2e356668f7d9/file",
            "id": "6c13a0e6-98a3-47fb-bee4-2e356668f7d9",
            "kernel_id": "578a708b-d0de-4a28-bcd2-8627ad15a971",
            "min_disk": 0,
            "min_ram": 0,
            "name": "cirros-0.3.4-x86_64-uec",
            "owner": "1f04217930f34b4a92fb11457783f2c0",
            "protected": false,
            "ramdisk_id": "0eaea69b-ebfd-40f3-bf86-13b8ad08462b",
            "schema": "/v2/schemas/image",
            "self": "/v2/images/6c13a0e6-98a3-47fb-bee4-2e356668f7d9",
            "size": 25165824,
            "status": "active",
            "tags": [],
            "updated_at": "2016-03-08T01:56:59Z",
            "virtual_size": null,
            "visibility": "public"
        },
        {
            "checksum": "be575a2b939972276ef675752936977f",
            "container_format": "ari",
            "created_at": "2016-03-08T01:56:57Z",
            "disk_format": "ari",
            "file": "/v2/images/0eaea69b-ebfd-40f3-bf86-13b8ad08462b/file",
            "id": "0eaea69b-ebfd-40f3-bf86-13b8ad08462b",
            "min_disk": 0,
            "min_ram": 0,
            "name": "cirros-0.3.4-x86_64-uec-ramdisk",
            "owner": "1f04217930f34b4a92fb11457783f2c0",
            "protected": false,
            "schema": "/v2/schemas/image",
            "self": "/v2/images/0eaea69b-ebfd-40f3-bf86-13b8ad08462b",
            "size": 3740163,
            "status": "active",
            "tags": [],
            "updated_at": "2016-03-08T01:56:57Z",
            "virtual_size": null,
            "visibility": "public"
        },
        {
            "checksum": "8a40c862b5735975d82605c1dd395796",
            "container_format": "aki",
            "created_at": "2016-03-08T01:56:54Z",
            "disk_format": "aki",
            "file": "/v2/images/578a708b-d0de-4a28-bcd2-8627ad15a971/file",
            "id": "578a708b-d0de-4a28-bcd2-8627ad15a971",
            "min_disk": 0,
            "min_ram": 0,
            "name": "cirros-0.3.4-x86_64-uec-kernel",
            "owner": "1f04217930f34b4a92fb11457783f2c0",
            "protected": false,
            "schema": "/v2/schemas/image",
            "self": "/v2/images/578a708b-d0de-4a28-bcd2-8627ad15a971",
            "size": 4979632,
            "status": "active",
            "tags": [],
            "updated_at": "2016-03-08T01:56:55Z",
            "virtual_size": null,
            "visibility": "public"
        }
    ],
    "schema": "/v2/schemas/images"
}
</code></pre>

<p> <code>X-My-Header:Value</code> is purely for demonstration purposes and is ignored by glance.
As you can see the output is nicely formatted and in a console even includes some pygments magic for coloring.</p>

<h2>Caveats</h2>

<p>os-http is at version 0.1 and has many unimplemented or not quite right things.
Most notably:</p>

<ul>
<li><p>There is really only support for GET and other body-less requests.
Whilst you can specify PUT/POST or other to method there is currently no means to specify body data so the request will be empty.
This would be easy to add but I havent used it so I haven&rsquo;t implemented it - contributions welcome.</p></li>
<li><p>The output is intended to be easy for a developer to consume, not for a script to parse (though this may be considered in future).
It is not intended to be a replacement for the existing CLIs in scripts.
The default output may change to include any additional information that could be useful to developers.</p></li>
<li><p>Because os-http does requests &lsquo;correctly&rsquo; you may find that using &ndash;os-api-version gives errors - particularly with nova.
This is because for most installations the service catalog for nova points to a protected endpoint.
There is ongoing work upstream to fix the service catalog in general but for now os-http doesn&rsquo;t contain the hacks that clients do to work around poor setups.
Using this tool may lead you to discover just how many hacks there are.</p></li>
</ul>


<p>Please test it out and report any feedback or bugs.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[User Auth in OpenStack Services]]></title>
    <link href="http://www.jamielennox.net/blog/2015/09/10/user-auth-in-openstack-services/"/>
    <updated>2015-09-10T15:19:24+10:00</updated>
    <id>http://www.jamielennox.net/blog/2015/09/10/user-auth-in-openstack-services</id>
    <content type="html"><![CDATA[<p>With auth plugins we are trying to ensure that an individual OpenStack service (like Nova or Glance) should never have to deal with the details of authentication.
One of the improvements we&rsquo;ve made that has gone largely unnoticed is the addition of the <strong>keystone.token_auth</strong> authentication plugin that is passed down in a request&rsquo;s environment variables from auth_token middleware.
This object is a full authentication plugin that uses the token and service catalog of the user that was just validated so that the service does the right thing without having to figure out keystone&rsquo;s token format.</p>

<p>This means that service to service communication is as simple as:</p>

<pre><code class="python">from glanceclient import client
import json
from keystoneclient import session
from keystonemiddleware import auth_token
from oslo_config import cfg
import webob.dec
from wsgiref import simple_server

cfg.CONF(project='testservice')

session.Session.register_conf_options(cfg.CONF, 'communication')
SESSION = session.Session.load_from_conf_options(cfg.CONF, 'communication')


@webob.dec.wsgify
def app(req):
    glance = client.Client('2',
                           session=SESSION,
                           auth=req.environ['keystone.token_auth'])

    return webob.Response(json.dumps([i.name for i in glance.images.list()]))


app = auth_token.AuthProtocol(app, {})
server = simple_server.make_server('', 8000, app)
server.serve_forever()
</code></pre>

<p>This is a full service that responds to every request with a JSON formatted list of image names in your project which is not all that useful but proves a point. There are some things to notice:</p>

<h4>The session is global.</h4>

<p>There are two ways to use a session with authentication.</p>

<ul>
<li>If you are writing something like a CLI application then you will want to use the same authentication for the lifetime of the program and it can be easier to just pass an auth plugin to the sesion constructor and forget about it.</li>
<li>If you are writing a service that wants to use many different authentications over its lifetime you can pass the auth directly to the client that will consume it.</li>
</ul>


<p>In our case we want to re-use the session for benefits like connection pooling and caching, but we will often change the authentication being used so we pass the plugin to the client directly.
The session is thread safe and is able to be reused across requests like this.
Consider this to be splitting the application context and the request context.</p>

<h4>We create the glanceclient just in time.</h4>

<p>As a very small application this isn&rsquo;t obvious however because all the caching and authentication logic is being handled by the session and plugin there is no reason to keep a client around.
Clients become very cheap to create and so in most situations you can use a client object within a function and then discard it.</p>

<h4>We never entered a URL for Glance.</h4>

<p>At no point did we have to provide a URL for glance in the config file.
If on any project you encounter you have to enter a fixed URL to communicate with another service please file a bug.
Keystone tokens have a service catalog in them so that all requests made on behalf of a user go to the appropriate URL.
In the past this was a relatively ugly affair involving parsing the information from dictionaries, however this is all encapsulated into the auth plugin now.</p>

<h4>There is additional information on the plugin</h4>

<p>Whilst not shown in the example the auth_plugin has the following attributes:</p>

<ul>
<li>user.auth_token</li>
<li>user.user_id</li>
<li>user.user_domain_id</li>
<li>user.project_id</li>
<li>user.project_domain_id</li>
<li>user.trust_id</li>
<li>user.role_names</li>
</ul>


<p>If you are storing the auth plugin in a context using these accessors can be much easier that trying to figure out the variables that auth_token middleware also set.</p>

<h4>You can&rsquo;t serialize the auth plugin.</h4>

<p>In the case of Nova and others the auth_token middleware check is performed on the API service however most service communication is done in a backend service.
We currently have no way of serializing the plugin to an oslo.context so it is reconstructed on the backend.
This is something we are working on.</p>

<h4>It&rsquo;s available now</h4>

<p>Going back to look at the initial review it is 5 days shy of 1 year old (merged 2014-09-15).
There have been improvements since then however the basic functionality has been out for a while and is available in the current minimum global requirements.
Glanceclient on the other hand has only had session support since the 1.0 release (2015-08-31) so you will need a recent version to test the example.</p>

<h2>Conclusion</h2>

<p>We are doing all we can to prevent services ever having to deal with the details of authentication in OpenStack.
If your project has still not adopted plugins please come find us in #openstack-keystone on freenode as it&rsquo;s currently making your life more difficult.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[V3 Authentication With Auth_token Middleware]]></title>
    <link href="http://www.jamielennox.net/blog/2015/02/23/v3-authentication-with-auth-token-middleware/"/>
    <updated>2015-02-23T10:57:46+11:00</updated>
    <id>http://www.jamielennox.net/blog/2015/02/23/v3-authentication-with-auth-token-middleware</id>
    <content type="html"><![CDATA[<p>Auth_token is the middleware piece in OpenStack responsible for validating tokens and passing authentication and authorization information down to the services.
It has been a long time complaint of those wishing to move to the V3 identity API that auth_token only supported the v2 API for authentication.</p>

<p>Then auth_token middleware adopted authentication plugins and the people rejoiced!</p>

<p>Or it went by almost completely unnoticed.
Auth is not an area people like to mess with once it&rsquo;s working and people are still coming to terms with configuring via plugins.</p>

<p>The benefit of authentication plugins is that it allows you to use <a href="http://www.jamielennox.net/blog/2015/02/17/loading-authentication-plugins/">any plugin you like for authentication</a> - including the v3 plugins.
A downside is that being able to load any plugin means that there isn&rsquo;t the same set of default options present in the sample config files that would indicate the new options available for setting.
Particularly as we have to keep the old options around for compatibility.</p>

<p>The most common configuration I expect for v3 authentication with auth_token middleware is:</p>

<pre><code class="ini">[keystone_authtoken]
auth_uri = https://public.keystone.uri:5000/
cafile = /path/to/cas

auth_plugin = password
auth_url = http://internal.keystone.uri:35357/
username = service
password = service_pass
user_domain_name = service_domain
project_name = project
project_domain_name = service_domain
</code></pre>

<p>The <code>password</code> plugin will query the <code>auth_url</code> for supported API versions and then use either v2 or v3 auth depending on what parameters you&rsquo;ve specified.
If you want to save a round trip (once on startup) you can use the <code>v3password</code> plugin which takes the same parameters but requires a V3 URL to be specified in <code>auth_url</code>.</p>

<p>An unfortunate thing we&rsquo;ve noticed from this is that there is going to be some confusion as most plugins present an <code>auth_url</code> parameter (used by the plugin to know where to authenticate the service user) along with the existing <code>auth_uri</code> parameter (reported in the headers of 403 responses to tell users where to authenticate).
This is a known issue we need to address and will likely result in changing the name of the <code>auth_uri</code> parameter as the concept of an <code>auth_url</code> is used by all existing clients and plugins.</p>

<p>For further proof that this works as expected checkout <a href="https://github.com/openstack-dev/devstack/blob/5ce44cd63b6e2b53f08a6b4b87cb4ab11d1ade26/lib/keystone#L448">devstack</a> which has been operating this way for a couple of weeks.</p>

<p><em>NOTE:</em> Support for authentication plugins was released in keystonemiddleware 1.3.0 released 2014-12-18.</p>
]]></content>
  </entry>
  
</feed>
