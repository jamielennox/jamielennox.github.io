<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: openstack | jamielennox.net]]></title>
  <link href="http://www.jamielennox.net/blog/categories/openstack/atom.xml" rel="self"/>
  <link href="http://www.jamielennox.net/"/>
  <updated>2014-02-18T12:19:27+10:00</updated>
  <id>http://www.jamielennox.net/</id>
  <author>
    <name><![CDATA[Jamie Lennox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dealing with .pyc]]></title>
    <link href="http://www.jamielennox.net/blog/2014/02/18/dealing-with-pyc/"/>
    <updated>2014-02-18T11:08:00+10:00</updated>
    <id>http://www.jamielennox.net/blog/2014/02/18/dealing-with-pyc</id>
    <content type="html"><![CDATA[<p>I have often found that when dealing with multiple branches and refactoring patches I get caught out by left over *.pyc files from python files that don&rsquo;t exist on this branch.
This bit me again recently so I went looking for options.</p>

<p>A useful environment variable that I found via some stackoverflow questions is: <a href="http://docs.python.org/2/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE">PYTHONDONTWRITEBYTECODE</a> which, when set, prevents python from writing .pyc and .pyo files.
This is not something that I want to set permanently on my machine but is great for development.</p>

<p>The other tool I use for all my python projects is <a href="http://virtualenvwrapper.readthedocs.org/en/latest/">virtualenvwrapper</a> which allows you to isolate project dependencies and environments in what I think is a more intuitive way than with virtualenv directly.</p>

<p>Armed with the simple idea that these two concepts should be able to work together I found I was not the first person to think of this.
There are other guides out there but the basic concept is simply to set PYTHONDONTWRITEBYTECODE when we activate a virtualenv and reset it when we deactivate it.</p>

<p>Easy.</p>

<p>Add to <em>~/.virtualenvs/postactivate</em>:</p>

<p><code>bash
export _PYTHONDONTWRITEBYTECODE=$PYTHONDONTWRITEBYTECODE
export PYTHONDONTWRITEBYTECODE=1
</code></p>

<p>Add to <em>~/.virtualenvs/predeactivate</em>:</p>

<p><code>bash
export PYTHONDONTWRITEBYTECODE=$_PYTHONDONTWRITEBYTECODE
unset _PYTHONDONTWRITEBYETCODE
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keystone Token Binding]]></title>
    <link href="http://www.jamielennox.net/blog/2013/10/22/keystone-token-binding/"/>
    <updated>2013-10-22T11:48:00+10:00</updated>
    <id>http://www.jamielennox.net/blog/2013/10/22/keystone-token-binding</id>
    <content type="html"><![CDATA[<p>With the Havana release of OpenStack, Keystone gains the ability to issue and verify tokens &ldquo;bound&rdquo; to some authentication mechanism.
To understand the reason for this feature we need to first consider the security model of the current token architecture.</p>

<p>OpenStack tokens are what we call &ldquo;bearer tokens&rdquo;.
The term seems to have come out of the OAuth movement but means that whoever has the token has all the rights associated with that person.
This is not an uncommon situation on the Internet, it is the way basic auth (username and password), cookies, and session ids all work, and one of the reasons that SSL is so important when authenticating against a website.
If an attacker was to get your token then they have all the rights of that token for as long as it is valid, including permission to reissue a token or change your password.
While all of these mechanism are symmetric secrets, they are only shared between two end points.
Keystone tokens are shared across all of the public services in an OpensStack deployment.</p>

<p>As OpenStack grows and this token is presented to an ever increasing list of services the vulnerability of this mechanism increases.
So what can we do about it?
The typical answer, particularly for the enterprise, is to use Kerberos or x509 client certificates.
This is a great solution but we don&rsquo;t want to have each service dealing with different authentication mechanisms, that&rsquo;s what Keystone does.</p>

<h2>What is a &ldquo;bound token&rdquo;?</h2>

<p>A &ldquo;bound token&rdquo; is a regular keystone token with some additional information that indicates that the token may only be used in conjunction with the specified external authentication mechanism.
Taking the example of Kerberos, when a token is issued Keystone embeds the name of the Kerberos principle into the token.
When this token is then presented to another service the service notices the bind information and ensures that Kerberos authentication was used and that the same user is making the request.</p>

<p>So how does this help to protect token hijacking?
To give an example:</p>

<ol>
<li> Alice connects to Keystone using her Kerberos credentials and gets a token.
 Embedded within this token is her Kerberos principal name <code>alice@ACME.COM</code>.</li>
<li> Alice authenticates to HaaS (hacked as a service) using her token and Kerberos credentials and is allowed to perform her operations.</li>
<li> Bob, who has privileged access to HaaS, records the token that Alice presented to the service (or otherwise gets Alice&rsquo;s token)</li>
<li> Bob attempts to connect to Keystone as Alice to change her password.
 He connects to keystone with his own Kerberos credentials <code>bob@ACME.COM</code>.
 Because these credentials do not match the ones that were present when the token was created his access is disallowed.</li>
</ol>


<p>It does not necessarily mean that the user initially authenticated themselves by there Kerberos credentials, they may have used there regular username and password.
It simply means that the user who created the token has said that they are also the owner of this Kerberos principal (note: that it is tied to the principal, not a ticket so it will survive ticket re-issuing) and the token should not be authenticated in future without it present.</p>

<h2>What is implemented?</h2>

<p>Currently tokens issued from Keystone can be bound to a Kerberos principal.
Extending this mechanism to x509 client certificates should be a fairly simple exercise but will not be included in the Havana release.</p>

<p>A patch to handle bind checking in auth_token middleware is currently under review to bring checking to other services.</p>

<p>There are however a number of problems with enforcing bound tokens today:</p>

<ul>
<li>Kerberos authentication is not supported by the eventlet http server (the server that drives most of the OpenStack web services), and so there is no way to authenticate to the server to provide the credentials.
This essentially restricts bind checking to services running in httpd, which to the best of my knowledge is currently only keystone and swift.</li>
<li>None of the clients currently support connecting with Kerberos authentication.
The option was added to Keystoneclient as a proof of concept but I am hoping that this can be solved across all clients by standardizing the way they communicate rather than having to add and maintain support in each individual client.
There will also be the issue of how to configure the servers to use these clients correctly.</li>
<li>Kerberos tickets are issued to users, not hosts, and typically expire after a period of time.
To allow unattended servers to have valid Kerberos credentials requires a way of automatically refreshing or fetching new tickets.
I am told that there is support for this scenario coming in Fedora 20 but I am not sure what it will involve.</li>
</ul>


<h2>Configuring Token Binding</h2>

<p>The new argument to enable token binding in <code>keystone.conf</code> is:</p>

<pre><code>[token]

# External auth mechanisms that should add bind information to token.
# eg kerberos, x509
bind = kerberos
</code></pre>

<p>As mentioned currently only the value Kerberos is currently supported here.
One of the next supported mechanisms will be x509 client certificates.</p>

<p>To enable token bind authentication in <code>keystone.conf</code> is:</p>

<pre><code>[token]
# Enforcement policy on tokens presented to keystone with bind information.
# One of disabled, permissive, strict, required or a specifically required bind
# mode e.g. kerberos or x509 to require binding to that authentication.
enforce_token_bind = permissive
</code></pre>

<p>As illustrated by the comments the possible values here are:</p>

<ul>
<li><code>disabled</code>: Disables token bind checking.</li>
<li><code>permissive</code>: Token bind information will be verified if present.
 If there is bind information for a token and the server does not know how to verify that information then it will be ignored and the token will be allowed.
 This is the new default value and should have no effect on existing systems.</li>
<li><code>strict</code>: Like permissive but if unknown bind information is present then the token will be rejected.</li>
<li><code>required</code>: Tokens will only be allowed if bind information is present and verified.</li>
<li>A specific form of bind information is present and verified.
The only currently available value here is <code>kerberos</code> indicating that a token must be bound to a Kerberos principal to be accepted.</li>
</ul>


<h2>In Conclusion</h2>

<p>For a deployment with access to a Kerberos or x509 infrastructure token binding will dramatically increase your user&rsquo;s security.
Unfortunately the limitations of Kerberos within OpenStack don&rsquo;t really make this a viable deployment option in Havana.
Watch this space however as we add x509 authentication and binding, and improve Kerberos handling throughout.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keystone with HTTPd in devstack]]></title>
    <link href="http://www.jamielennox.net/blog/2013/09/30/keystone-with-httpd-in-devstack/"/>
    <updated>2013-09-30T13:53:00+10:00</updated>
    <id>http://www.jamielennox.net/blog/2013/09/30/keystone-with-httpd-in-devstack</id>
    <content type="html"><![CDATA[<p>Keystone has been slowly pushing away from being deployed with <a href="http://eventlet.net">Eventlet</a> and the <code>keystone-all</code> script in favour of the more traditional httpd mod_wsgi application method.
There has been discussion of Eventlet&rsquo;s place in OpenStack <a href="http://davidhadas.wordpress.com/2012/05/14/asynchronousio/">before</a> and its (mis)use has led to numerous subtle bugs and problems, however from my opinion in Keystone the most important reasons to move away from Eventlet are:</p>

<ul>
<li>Eventlet does not support Kerberos authentication.</li>
<li>pyOpenSSL only releases the GIL around some SSL verification commands.
This leads to a series of hacks to prevent long running crypto commands blocking Eventlet threads and thus the entire Keystone process.</li>
<li>There are already a lot of httpd authentication/authorization plugins that we could make use of in Keystone.</li>
<li>It&rsquo;s faster to have things handled by httpd modules in C than in Python.</li>
</ul>


<p>Keystone has shipped with sample WSGI scripts and httpd configuration files since Foslom and documentation for how to use them <a href="http://docs.openstack.org/developer/keystone/apache-httpd.html">is available</a> however most guides and service wrappers (upstart, systemd etc) will use the <code>keystone-all</code> method.</p>

<p>To get some wider adoption and understanding of the process I&rsquo;ve just added Keystone with httpd support into devstack.
Simply set:
<code>
APACHE_ENABLED_SERVICES=key
</code>
in your localrc or environment variables and re-run <code>./stack.sh</code> to try it out.</p>

<p>P.S. Swift can also be deployed this way by adding <code>swift</code> to the (comma separated) services list.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APIClient Communications]]></title>
    <link href="http://www.jamielennox.net/blog/2013/09/27/apiclient-communications/"/>
    <updated>2013-09-27T15:27:00+10:00</updated>
    <id>http://www.jamielennox.net/blog/2013/09/27/apiclient-communications</id>
    <content type="html"><![CDATA[<p>There has been interest recently in porting novaclient&rsquo;s authentication plugin system to the rest of the OpenStack client libraries and moving the plugins into keystoneclient.
At a similar time <a href="http://aababilov.wordpress.com">Alessio Ababilov</a> started trying to introduce the concept of a <a href="http://openstackgd.wordpress.com/2013/01/12/preconditions-for-common-openstack-client-library/">common base client</a> into keystoneclient.
This is a fantastic idea and one that is well supported by the Keystone, Oslo and I&rsquo;m sure other teams.
I&rsquo;ve been referring to this move as APIClient as that is the name of the folder in Oslo code.
At its core is a change in how clients communicate that will result in some significant changes to the base client objects and incorporate these plugins.</p>

<p>Keystone is interested in handling how communication is managed within OpenStack, not just for tokens but as we bring in client certificate and kerberos authentication it will need to have influence over the requests being sent.
After discussing the situation with Alessio he agreed to let me take his base work and start the process of getting these changes into keystoneclient with the intent that this pattern be picked up by other OpenStack clients.
This has unfortunately been a slower process than I would have liked and I think it is hampered by a lack of clear understanding in what is trying to be achieved, which I hope to address with this post.
What follows is in the vein of Alessio&rsquo;s ideas and definitely a result of his work but is my own interpretation of the problem and the implementation has been rewritten from that initial work.</p>

<p>Most OpenStack clients have the concept of a HTTPClient which abstracts the basic communication with a server, however projects differ in what this object is and how it is used.
Novaclient creates an instance of a HTTPClient object which it saves as <code>self.client</code> (for yet another candidate for what a client object is).
Much of what the novaclient object does then in terms of setting and using authentication plugins is simply a wrapper around calls to the HTTPClient object.
Managers (the part of client responsible for a resource eg user, project etc) are provided with a reference to the base client object (this time saved as <code>api</code>) and so make requests in the form <code>self.api.client.get</code>.
Keystoneclient subclasses HTTPClient and managers make calls in the form <code>self.api.get</code>.
Other projects can go either way depending on which client they were using as reference.</p>

<p>My <em>guess</em> here is that when keystoneclient was initially split out from novaclient the subclassing of HTTPClient was intentional, such that keystoneclient would provide an authenticated HTTPClient that novaclient would use.
Keystoneclient however has its own managers and requirements and the projects have sufficiently diverged so that it no longer fits into this role.
To this day novaclient does not use keystoneclient (in any way) and introduced authentication plugins instead.</p>

<p>If there is going to be a common communication framework then there must be a decision between:</p>

<ul>
<li>Standardizing on a common base client class that is capable of handling communication (as keystoneclient does).</li>
<li>Create a standalone communication object that clients make use of (as novaclient does).</li>
</ul>


<p>The APIClient design goes for the latter.
We create a communication object that can be used by any type of client <em>and</em> be reused by different instances of clients (which novaclient does not currently allow).
This communication object is passed between clients deprecating some of the ever increasing list of parameters passed to clients and changes the flow from authenticating a client to authenticating a channel that clients can make use of.
This centralizes authentication and token fetching (including kerberos and client certs), catalog management and endpoint selection and will let us address caching, HTTP session management etc in the future.</p>

<p>In the initial APIClient this object was the new HTTPClient, however this term was so abused I am currently using ClientSession (as it is built on the requests library and is similar to the requests.Session concept) but debate continues.</p>

<p>This is where authentication plugins will live so that any communication through a ClientSession object can request a token added from the plugin.
Maintaining the plugin architecture is preferred here to simply having multiple ClientSession subclasses to allow independent storing and caching of authentication, plugin discovery, and changing or renewing authentication.</p>

<p>So an example of the new workflow is:</p>

<p>```python
from keystoneclient.auth.identity import v3_auth
from keystoneclient import session
from keystoneclient.v3 import client as v3_client
from novaclient.v1_1 import client</p>

<p>auth = v3_auth.Auth(username=&lsquo;username&rsquo;,</p>

<pre><code>                password='password',
                project_id='project_id',
                auth_url='https://keystone.example.com')
</code></pre>

<p>client_session = session.ClientSession(auth)</p>

<p>keystone_client = v3_client.Client(client_session)
nova_client = client.Client(client_session)
```</p>

<p>It is obviously a little longer than the current method but I&rsquo;m sure that the old syntax can be maintained for when you only need a single client.</p>

<p>Implementations of this are starting to go into review on keystoneclient.
For the time being some features from nova such as authentication plugins specifying CLI arguments are not being considered until we can ensure that the new system meets at least the current functionality.</p>

<p>The major problem found so far is maintaining API compatibility.
Much of what is currently on keystoneclient that will be moved is defined publicly and cannot simply be thrown away even though they are typically attributes and abstract functions that a user should have no need of.</p>

<p>Hopefully this or something very similar will be coming to the various OpenStack clients soon.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[User access to libvirtd]]></title>
    <link href="http://www.jamielennox.net/blog/2013/04/09/user-access-to-libvirtd/"/>
    <updated>2013-04-09T11:50:00+10:00</updated>
    <id>http://www.jamielennox.net/blog/2013/04/09/user-access-to-libvirtd</id>
    <content type="html"><![CDATA[<p>To enable access to libvirtd without sudo:</p>

<ol>
<li>Create a group for privileged users, I called mine <code>libvirt</code> and add your users to it.</li>
<li>Create a new file in <code>/etc/polkit-1/rules.d/</code> i called mine <code>50-libvirt-group.rules</code></li>
<li>Add the following function:
<code>
polkit.addRule(function(action, subject) {
 if (action.id == "org.libvirt.unix.manage" &amp;&amp;
     subject.isInGroup('libvirt') ) {
     return polkit.Result.YES;
 }
});
</code></li>
</ol>

]]></content>
  </entry>
  
</feed>
